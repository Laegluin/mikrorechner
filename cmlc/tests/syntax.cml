type Variant =
    | One
    | Two i32
    | Three i32, i32
    | User User;

fn variant = -> Variant {
    let a = Variant::Three: 1, 2;
    let b = Variant::One;
}

type User = {
    id: i32,
    name: *str,
}

fn user = -> User {
    User: 
        id = 1,
        name = "name",
    
}

type SpecialFn = *fn i32, i32 -> i32;
type NoReturnFn = *fn i32, i32;
type ZeroArgFn = *fn -> i32;

fn add_three = first: i32, second: i32, third: i32 -> i32 {
    first + second + third
}

fn println = msg: *str -> () {

}

fn do_stuff = -> () {

}

fn get_stuff = -> i32 {
    42
}

fn main = -> i32 {
    function_call: arg1, arg2, arg3;
    named_args: arg1 = 1, arg2 = 2, arg3 = 3;
    object method_call: arg1, arg2;
    let array: [i32; 3] = [1, 2, 3];

    object zero_arg_method!;
    zero_arg_function!;

    // method chaining
    open_file: "test.txt"
        truncate: true
        write: true
        clear!
        set_permissions: "rwx", "r-x", "r-x",
        set_name: "changed.txt"
        close!;

    if is_open: "file" {
        ret 0;
    } else {
        ret -1;
    }

    if 1 + 2 > 0 {
        let three = 1 plus: 2 plus: 3;
        let three = plus: (plus: 1, 2), 3
    }

    if !true && false || true {
        explode!;
    }
}

fn plus = lhs: i32, rhs: i32 -> i32 {
    lhs + rhs
}

type Record = {
    ptr_field: *i32,
}

fn dangling_ptr = -> *mut Record {
    let some_record = Record: ptr_field = &42;
    let eq_record = Record: &42;

    let some_record_ptr: *Record = &some_record;
    *some_record_ptr->ptr_field = 42;
    *some_record.ptr_field = &13;
    &mut some_record
}

fn inferred_args = left, right -> u32 {
    left + right
}

fn inferred_return = {
    1 + 2
}

fn inferred_everything = arg1, arg2 {
    arg1 - arg2
}
